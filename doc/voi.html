<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Christopher Jackson" />


<title>voi for Value of Information calculation: package overview</title>

<script src="data:application/javascript;base64,Ly8gUGFuZG9jIDIuOSBhZGRzIGF0dHJpYnV0ZXMgb24gYm90aCBoZWFkZXIgYW5kIGRpdi4gV2UgcmVtb3ZlIHRoZSBmb3JtZXIgKHRvCi8vIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmVoYXZpb3Igb2YgUGFuZG9jIDwgMi44KS4KZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKGUpIHsKICB2YXIgaHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCJkaXYuc2VjdGlvbltjbGFzcyo9J2xldmVsJ10gPiA6Zmlyc3QtY2hpbGQiKTsKICB2YXIgaSwgaCwgYTsKICBmb3IgKGkgPSAwOyBpIDwgaHMubGVuZ3RoOyBpKyspIHsKICAgIGggPSBoc1tpXTsKICAgIGlmICghL15oWzEtNl0kL2kudGVzdChoLnRhZ05hbWUpKSBjb250aW51ZTsgIC8vIGl0IHNob3VsZCBiZSBhIGhlYWRlciBoMS1oNgogICAgYSA9IGguYXR0cmlidXRlczsKICAgIHdoaWxlIChhLmxlbmd0aCA+IDApIGgucmVtb3ZlQXR0cmlidXRlKGFbMF0ubmFtZSk7CiAgfQp9KTsK"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<link rel="stylesheet" href="data:text/css,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" type="text/css" />




</head>

<body>




<h1 class="title toc-ignore">voi for Value of Information calculation: package overview</h1>
<h4 class="author">Christopher Jackson</h4>
<h4 class="date">16/07/2021</h4>


<div id="TOC">
<ul>
<li><a href="#simple-example-model">Simple example model</a>
<ul>
<li><a href="#specifying-model-inputs">Specifying model inputs</a></li>
<li><a href="#specifying-model-outputs">Specifying model outputs</a></li>
</ul></li>
<li><a href="#expected-value-of-perfect-information">Expected value of perfect information</a></li>
<li><a href="#expected-value-of-partial-perfect-information">Expected value of partial perfect information</a>
<ul>
<li><a href="#invoking-the-evppi-function.">Invoking the <code>evppi</code> function.</a></li>
<li><a href="#changing-the-default-calculation-method">Changing the default calculation method</a></li>
<li><a href="#traditional-monte-carlo-nested-loop-method">Traditional Monte Carlo nested loop method</a></li>
</ul></li>
<li><a href="#expected-value-of-sample-information">Expected value of sample information</a>
<ul>
<li><a href="#function-to-generate-study-data">Function to generate study data</a></li>
<li><a href="#built-in-study-designs">Built-in study designs</a></li>
<li><a href="#importance-sampling-method">Importance sampling method</a></li>
<li><a href="#further-work">Further work</a></li>
</ul></li>
</ul>
</div>

<p>Value of Information methods are used in models for making decisions. They describe the expected value of getting more information of various kinds.</p>
<p>The theory of the methods and details on how to use them in practice are described in several papers and books (some will be linked in this document).</p>
<p>While some details may not be fully explained in the current draft of this document, the <code>voi</code> package is intended to accompany a book which is under preparation. When the book is finished, it will provide all background information that users of the package will need to know.</p>
<p>This document gives a very simple overview of how the package is used. A simple example model is used, but the same methods work for more complex models.</p>
<div id="simple-example-model" class="section level2">
<h2>Simple example model</h2>
<p>Suppose we are making a decision between two treatments. Treatment 1 has no costs or effects. Treatment 2 has a <em>net benefit</em> which describes its average costs and effects for a population. We choose Treatment 2 if its <em>incremental net benefit</em>, relative to treatment 1, is positive. The incremental net benefit in this simple case is identical to the net benefit of treatment 2, since the net benefit of treatment 1 is zero.</p>
<p>Suppose that the net benefit is simply defined as the difference between two uncertain <em>parameters</em>, <span class="math inline">\(y(p_1,p_2) = p_1 - p_2\)</span>, where <span class="math inline">\(p_1\)</span> gives the effects, and <span class="math inline">\(p_2\)</span> gives the costs. Our current uncertainty can be described by normal distributions <span class="math inline">\(p_1 \sim N(1,1)\)</span> and <span class="math inline">\(p_2 \sim N(0,2)\)</span>.</p>
<p>To make a decision under parameter uncertainty, one option is preferred to another if the <em>expectation</em> of its net benefit, with respect to the uncertainty, is greater. In this case, we choose treatment 2, because the net benefit is distributed as <span class="math inline">\(N(1, \sqrt{1^2+2^2}) = N(1, \sqrt{5})\)</span> which has an expectation of 1, whereas treatment 1 has a known net benefit of zero.</p>
<p>Most of the functions in the <code>voi</code> package work with a <em>random sample</em> of model inputs and outputs. For the example model, these are simple to generate, as follows.</p>
<div id="specifying-model-inputs" class="section level3">
<h3>Specifying model inputs</h3>
<p>The inputs should be a data frame with one column per parameter and one row per random sample.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>) </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>nsam <span class="ot">&lt;-</span> <span class="dv">10000</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>inputs <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">p1 =</span> <span class="fu">rnorm</span>(nsam, <span class="dv">1</span>, <span class="dv">1</span>), </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">p2 =</span> <span class="fu">rnorm</span>(nsam, <span class="dv">0</span>, <span class="dv">2</span>))</span></code></pre></div>
</div>
<div id="specifying-model-outputs" class="section level3">
<h3>Specifying model outputs</h3>
<p>The outputs can be supplied in either of two forms.</p>
<p><strong>Net benefit</strong> form. A data frame with one column per treatment, and one row per random sample, giving the net benefit of each treatment. In this example, the net benefit of treatment 1 is zero.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>outputs_nb <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">t1 =</span> <span class="dv">0</span>, </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                         <span class="at">t2 =</span> inputs<span class="sc">$</span>p1 <span class="sc">-</span> inputs<span class="sc">$</span>p2)</span></code></pre></div>
<p><strong>Cost-effectiveness analysis</strong> form. This should be a list that includes the following three named elements (in any order)</p>
<ul>
<li><p><code>&quot;c&quot;</code>: a data frame with one column per treatment and one row per random sample, containing the expected costs of the treatment.</p></li>
<li><p><code>&quot;e&quot;</code>: a data frame with one column per treatment and one row per random sample, containing the expected effects of the treatment.</p></li>
<li><p><code>&quot;k&quot;</code>: a vector of values giving alternative amounts that a decision-maker is willing to pay for one unit of effectiveness, so that the net benefit is <span class="math inline">\(e \times k - c\)</span>. [ TODO accept the name wtp too ]</p></li>
</ul>
<p>In this simple example, the parameter <span class="math inline">\(p_1\)</span> gives the effects, and <span class="math inline">\(p_2\)</span> the costs of treatment 2, and the net benefit <span class="math inline">\(y = p_1 - p_2\)</span> defined in <code>outputs_nb</code> corresponds to a willingness-to-pay of <span class="math inline">\(k=1\)</span>. The cost-effectiveness format allows us compare VoI between different willingness-to-pay values, e.g. 1, 2 and 3 say here.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>outputs_cea <span class="ot">&lt;-</span> <span class="fu">list</span>( </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">e =</span> <span class="fu">data.frame</span>(<span class="at">t1 =</span> <span class="dv">0</span>, <span class="at">t2 =</span> inputs<span class="sc">$</span>p1), </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">c =</span> <span class="fu">data.frame</span>(<span class="at">t1 =</span> <span class="dv">0</span>, <span class="at">t2 =</span> inputs<span class="sc">$</span>p2), </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">k =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Note that objects returned by the <code>bcea</code> function in the <a href="https://CRAN.R-project.org/package=BCEA">BCEA</a> package satisfy this format.</p>
</div>
</div>
<div id="expected-value-of-perfect-information" class="section level2">
<h2>Expected value of perfect information</h2>
<p>The <em>expected value of perfect information</em> is the expected net benefit given perfect information minus the expected net benefit given current information.</p>
<p>Given current information, we decided on treatment 2. Our expected net benefit under current information is 1, the mean of the distribution of treatment 2’s net benefit.</p>
<p>Random sampling can be used to illustrate how to compute the expected net benefit given perfect information. Each sample of parameter values mimics a situation of decision-making given perfect information, where we know the parameters take these values. For each sample, we compare the corresponding treatment 2 net benefit to the threshold of zero, and prefer treatment 1 if the net benefit is negative, and treatment 2 if the net benefit is positive. The net benefit in each case is the net benefit of the chosen treatment given the “known” parameter values from the current samples.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>decision_current <span class="ot">&lt;-</span> <span class="dv">2</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>nb_current <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>decision_perfect <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(outputs_nb<span class="sc">$</span>t2 <span class="sc">&lt;</span> <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>nb_perfect <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(decision_perfect <span class="sc">==</span> <span class="dv">1</span>, <span class="dv">0</span>, outputs_nb<span class="sc">$</span>t2)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>(evpi <span class="ot">&lt;-</span> <span class="fu">mean</span>(nb_perfect) <span class="sc">-</span> nb_current)</span></code></pre></div>
<pre><code>## [1] 0.4778316</code></pre>
<p>An alternative view is in terms of <em>opportunity loss</em> which is the net benefit of the better decision we should have made (if we had known the truth), minus the net benefit of the decision we did make. The opportunity loss can be computed at each sample as follows. The EVPI is the mean of the opportunity loss.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>opp_loss <span class="ot">&lt;-</span> nb_perfect <span class="sc">-</span> nb_current</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">mean</span>(opp_loss)</span></code></pre></div>
<pre><code>## [1] 0.4778316</code></pre>
<p>Note that taking the mean over sampled values corresponds to estimating an expectation of the uncertainty distribution from which the values were sampled.</p>
<p>The <code>voi</code> package contains a simple function <code>evpi</code> to compute the EVPI using the above procedure. The function automatically detects whether your outputs are in net benefit or cost-effectiveness format.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(voi)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">evpi</span>(outputs_nb)</span></code></pre></div>
<pre><code>## [1] 0.4759885</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evpi</span>(outputs_cea)</span></code></pre></div>
<pre><code>## [1] 0.4759885 0.4028003 0.4174207</code></pre>
<p>In this simple example, the EVPI can also be calculated “by hand”, because the model just involves normal distributions. The probability that the decision under perfect information agrees with the decision under current information, in this case, is the probability that the true value of a <span class="math inline">\(y \sim N(1, \sqrt{5})\)</span> is actually positive.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>prob_correct <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">pnorm</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fu">sqrt</span>(<span class="dv">5</span>))</span></code></pre></div>
<p>The mean of <code>nb_perfect</code> can then be calculated as the expected net benefit given a correct decision, multiplied by the probability of a correct decision. The former is the mean of the values of <code>outputs_nb$t2</code> which are positive, which is the mean of a <span class="math inline">\(N(1,\sqrt{5})\)</span> truncated below at zero, and the mean of the truncated normal distribution has a <a href="https://en.wikipedia.org/wiki/Truncated_normal_distribution">analytic form</a></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>mean_truncnorm <span class="ot">&lt;-</span> <span class="cf">function</span>(mu, sig, <span class="at">lower=</span><span class="sc">-</span><span class="cn">Inf</span>, <span class="at">upper=</span><span class="cn">Inf</span>){ </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> (lower<span class="sc">-</span>mu)<span class="sc">/</span>sig</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> (upper<span class="sc">-</span>mu)<span class="sc">/</span>sig</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  mu <span class="sc">+</span> sig <span class="sc">*</span> (<span class="fu">dnorm</span>(a) <span class="sc">-</span> <span class="fu">dnorm</span>(b)) <span class="sc">/</span> (<span class="fu">pnorm</span>(b) <span class="sc">-</span> <span class="fu">pnorm</span>(a))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>enb_correct <span class="ot">&lt;-</span> <span class="fu">mean_truncnorm</span>(<span class="dv">1</span>, <span class="fu">sqrt</span>(<span class="dv">5</span>), <span class="at">lower=</span><span class="dv">0</span>) </span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>mean_nb_perfect <span class="ot">&lt;-</span> enb_correct <span class="sc">*</span> prob_correct</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>(evpi <span class="ot">&lt;-</span> mean_nb_perfect <span class="sc">-</span> nb_current)</span></code></pre></div>
<pre><code>## [1] 0.4798107</code></pre>
<p>This analytic result is expected to be more accurate than the value from Monte Carlo simulation. Unfortunately most realistic decision-analytic models do not have such a nice form, and we must rely on Monte Carlo methods to calculate the expected value of information.</p>
</div>
<div id="expected-value-of-partial-perfect-information" class="section level2">
<h2>Expected value of partial perfect information</h2>
<p>The <em>expected value of partial perfect information</em> (EVPPI) for a parameter <span class="math inline">\(\phi\)</span> in a decision-analytic model is the expected value of learning the exact value of that parameter, while the other parameters remain uncertain. <span class="math inline">\(\phi\)</span> can comprise a single scalar parameter, or multiple parameters. If <span class="math inline">\(\phi\)</span> refers to multiple parameters then the EVPPI describes the expected value of learning <em>all</em> of these parameters, often referred to as the <em>multiparameter</em> EVPPI.</p>
<p>The EVPPI is defined as the expected net benefit given perfect knowledge of <span class="math inline">\(\phi\)</span>, minus the expected net benefit given current information. [ algebraic def ]</p>
<p>The function <code>evppi</code> can be used to compute this.</p>
<p>There are a variety of alternative computational methods implemented in this function. The default methods are based on nonparametric regression, and come from <a href="https://doi.org/10.1177/0272989X13505910">Strong et al.</a>. If there are four or fewer parameters, then a generalized additive model is used. With five or more, then (TODO FIX INLA) is used.</p>
<div id="invoking-the-evppi-function." class="section level3">
<h3>Invoking the <code>evppi</code> function.</h3>
<p>To call <code>evppi</code>, supply a sample of outputs and inputs (in the same form REF) in the first two arguments. The parameter or parameters of interest (whose EVPPI is desired) is supplied in the <code>&quot;pars&quot;</code> argument. This can be expressed in various ways.</p>
<p><strong>(a) As a vector</strong>. The joint EVPPI is computed for all parameters in this vector. If the vector has more than one element, then the function returns the expected value of perfect information on all of these parameters simultaneously (described as the “multiparameter” EVPPI by <a href="https://doi.org/10.1177/0272989X13505910">Strong et al.</a>).</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="st">&quot;p1&quot;</span>)</span></code></pre></div>
<pre><code>##        evppi
## 1 0.08210074</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="fu">c</span>(<span class="st">&quot;p1&quot;</span>,<span class="st">&quot;p2&quot;</span>))</span></code></pre></div>
<pre><code>##       evppi
## 1 0.4759885</code></pre>
<p><strong>(b) As a list</strong>. A separate EVPPI is computed for each element of the list. In the second example below, this is the EVPPI of <span class="math inline">\(p_1\)</span>, followed by the multiparameter EVPPI of “p_1” and “p_2”. Note that the multiparameter EVPPI is the same as the EVPI if, as in this case, the vector includes all of the parameters in the model.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="fu">list</span>(<span class="st">&quot;p1&quot;</span>,<span class="st">&quot;p2&quot;</span>))</span></code></pre></div>
<pre><code>##   pars      evppi
## 1   p1 0.08210074
## 2   p2 0.39029827</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="fu">list</span>(<span class="st">&quot;p1&quot;</span>,<span class="fu">c</span>(<span class="st">&quot;p1&quot;</span>,<span class="st">&quot;p2&quot;</span>)))</span></code></pre></div>
<pre><code>##    pars      evppi
## 1    p1 0.08210074
## 2 p1,p2 0.47598851</code></pre>
<p>The <code>evppi</code> function returns a data frame with columns indicating the parameter (or parameters), and the corresponding EVPPI. If the outputs are in cost-effectiveness analysis format, then a separate column is returned indicating the willingness-to-pay.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_cea, inputs, <span class="at">pars=</span><span class="fu">list</span>(<span class="st">&quot;p1&quot;</span>,<span class="fu">c</span>(<span class="st">&quot;p1&quot;</span>,<span class="st">&quot;p2&quot;</span>)))</span></code></pre></div>
<pre><code>##    pars k      evppi
## 1    p1 1 0.08210074
## 2 p1,p2 1 0.47598851
## 3    p1 2 0.17052564
## 4 p1,p2 2 0.40280031
## 5    p1 3 0.25895085
## 6 p1,p2 3 0.41742073</code></pre>
<p>Some methods have a SE option TODO</p>
</div>
<div id="changing-the-default-calculation-method" class="section level3">
<h3>Changing the default calculation method</h3>
<p>The method can be changed by supplying the <code>method</code> argument to <code>evppi</code>. Some methods have additional options to tune them. For a full list of these options, see <code>help(evppi)</code>.</p>
<div id="gaussian-process-regression" class="section level4">
<h4>Gaussian process regression</h4>
<p>(<a href="https://doi.org/10.1177/0272989X13505910">Strong et al.</a>). The number of random samples to use in this computation can be changed using the <code>nsim</code> argument, which can be useful for this method as it can be prohibitive for large samples. Here the sample of 10000 is reduced to 1000.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="st">&quot;p1&quot;</span>, <span class="at">method=</span><span class="st">&quot;gp&quot;</span>, <span class="at">nsim=</span><span class="dv">1000</span>)</span></code></pre></div>
<pre><code>## [1] &quot;calling optim function for net benefit&quot;
## [1] &quot;calling optim function for net benefit&quot;</code></pre>
<pre><code>##        evppi
## 1 0.08834038</code></pre>
</div>
<div id="multivariate-adaptive-regression-splines" class="section level4">
<h4>Multivariate adaptive regression splines</h4>
<p>This is a variant of generalized additive models based on linear splines, and is based on a package called <a href="https://CRAN.R-project.org/package=earth">earth</a>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="st">&quot;p1&quot;</span>, <span class="at">method=</span><span class="st">&quot;earth&quot;</span>)</span></code></pre></div>
<pre><code>##        evppi
## 1 0.08810086</code></pre>
</div>
<div id="inla-method" class="section level4">
<h4>INLA method</h4>
<p>(<a href="https://onlinelibrary.wiley.com/doi/full/10.1002/sim.6983">Heath et al.</a>, <a href="https://link.springer.com/content/pdf/10.1007/978-3-319-55718-2.pdf">Baio et al.</a> ). This needs the following extra packages to be installed, using the following commands. (As of writing, the <code>ldr</code> package is not on CRAN due to lack of maintenance, but the archived version has been used without any noticeable problem.)</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&#39;INLA&#39;</span>, <span class="at">repos=</span><span class="st">&#39;https://inla.r-inla-download.org/R/stable&#39;</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&#39;splancs&#39;</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>devtools<span class="sc">::</span><span class="fu">install_version</span>(<span class="st">&quot;ldr&quot;</span>, <span class="at">version =</span> <span class="st">&quot;1.3.3&quot;</span>, <span class="at">repos =</span> <span class="st">&quot;http://cran.uk.r-project.org&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="fu">c</span>(<span class="st">&quot;p1&quot;</span>,<span class="st">&quot;p2&quot;</span>), <span class="at">method=</span><span class="st">&quot;inla&quot;</span>)</span></code></pre></div>
</div>
<div id="tuning-the-generalized-additive-model-method" class="section level4">
<h4>Tuning the generalized additive model method</h4>
<p>The generalized additive model formula can be changed with the <code>gam_formula</code> argument. This is supplied to the <code>gam</code> function from the <code>mgcv</code> package. The default formula uses a tensor product, and if there are more than four parameters, then a basis dimension of 4 terms per parameter is assumed.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="fu">c</span>(<span class="st">&quot;p1&quot;</span>,<span class="st">&quot;p2&quot;</span>), <span class="at">method=</span><span class="st">&quot;gam&quot;</span>, <span class="at">gam_formula=</span><span class="st">&quot;s(p1) + s(p2)&quot;</span>)</span></code></pre></div>
<pre><code>##       evppi
## 1 0.4759885</code></pre>
</div>
<div id="single-parameter-methods" class="section level4">
<h4>Single-parameter methods</h4>
<p>These are only applicable for computing the EVPPI for a single scalar parameter. They are supplied in the package for technical completeness, but for single-parameter EVPPI we have found it to be sufficiently reliable to use the default GAM method.</p>
<p>(<a href="https://journals.sagepub.com/doi/full/10.1177/0272989X12465123">Strong and Oakley</a>)</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="st">&quot;p1&quot;</span>, <span class="at">n.blocks=</span><span class="dv">20</span>, <span class="at">method=</span><span class="st">&quot;so&quot;</span>)</span></code></pre></div>
<pre><code>##        evppi
## 1 0.07997543</code></pre>
<p>(<a href="https://doi.org/10.1016/j.jval.2012.10.018">Sadatsafavi et al.</a>)</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi</span>(outputs_nb, inputs, <span class="at">pars=</span><span class="st">&quot;p1&quot;</span>, <span class="at">method=</span><span class="st">&quot;sal&quot;</span>)</span></code></pre></div>
<pre><code>##        evppi
## 1 0.08151919</code></pre>
</div>
</div>
<div id="traditional-monte-carlo-nested-loop-method" class="section level3">
<h3>Traditional Monte Carlo nested loop method</h3>
<p>(<a href="https://doi.org/10.1177/0272989x07302555">Brennan et al.</a>)</p>
<p>This is generally too slow to provide reliable EVPPI estimates in realistic models, but is provided in this package for technical completeness.</p>
<p>This method is available in the function <code>evppi_mc</code>. It requires the user to supply two functions.</p>
<ol style="list-style-type: lower-alpha">
<li>a function to evaluate the decision-analytic model for specific parameter values. This must have one argument for each parameter. The return value can be in either a “net benefit” form or a “costs and effects” form. The “net benefit” form is a vector giving the net benefit for each decision option.</li>
</ol>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>model_fn_nb <span class="ot">&lt;-</span> <span class="cf">function</span>(p1, p2){ </span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="dv">0</span>, p1 <span class="sc">-</span> p2) </span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The “costs and effects” form is a matrix with two rows, and one column for each decision option. The rows gives the effects and costs respectively for each decision option. If they have names <code>&quot;e&quot;</code> and <code>&quot;c&quot;</code> then these are assumed to identify the effects and costs. Otherwise the first row is assumed to contain the effects, and the second the costs.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>model_fn_cea <span class="ot">&lt;-</span> <span class="cf">function</span>(p1, p2){ </span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rbind</span>(<span class="at">e =</span> <span class="fu">c</span>(<span class="dv">0</span>, p1), </span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">c =</span> <span class="fu">c</span>(<span class="dv">0</span>, p2)) </span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<ol start="2" style="list-style-type: lower-alpha">
<li>a function to generate a random sample of <span class="math inline">\(n\)</span> values from the current (joint) uncertainty distribution of the model parameters. This returns a data frame with <span class="math inline">\(n\)</span> rows and one named column for each parameter.</li>
</ol>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>par_fn <span class="ot">&lt;-</span> <span class="cf">function</span>(n){</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">data.frame</span>(<span class="at">p1 =</span> <span class="fu">rnorm</span>(n, <span class="dv">1</span>, <span class="dv">1</span>),</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">p2 =</span> <span class="fu">rnorm</span>(n, <span class="dv">0</span>, <span class="dv">2</span>))</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>These functions are then supplied as arguments to <code>evppi_mc</code>, along with the number of samples to draw in the inner and outer loops. 1000 inner samples and 100 outer samples give a reasonable EVPPI estimate in this example, but many more samples may be required for the result to converge to the EVPPI in more complex models.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evppi_mc</span>(model_fn_nb, par_fn, <span class="at">pars=</span><span class="st">&quot;p1&quot;</span>, <span class="at">ninner=</span><span class="dv">1000</span>, <span class="at">nouter=</span><span class="dv">100</span>)</span></code></pre></div>
</div>
</div>
<div id="expected-value-of-sample-information" class="section level2">
<h2>Expected value of sample information</h2>
<p>The <em>expected value of sample information</em> is the expected value of collecting a specific amount of data from a study designed to give information about some model parameter or parameters. It is defined as the expected net benefit given the study data, minus the expected net benefit with current information.</p>
<p>The function <code>evsi</code> can be used to calculate this. The default method is based on nonparametric regression (from <a href="https://dx.doi.org/10.1177%2F0272989X15575286">Strong et al.</a>). This requires the user to either</p>
<ol style="list-style-type: lower-alpha">
<li><p>supply an R function to generate and summarise the study data, or</p></li>
<li><p>use one of the built-in study designs, and specify which of the model parameters are informed by this study.</p></li>
</ol>
<p>To illustrate how to use <code>evsi</code>, suppose we want to collect a sample of <span class="math inline">\(n\)</span> normally-distributed observations in order to get a better estimate of the treatment 2 effectiveness <span class="math inline">\(p_1\)</span>. Under current information, <span class="math inline">\(p_1\)</span> is distributed as <span class="math inline">\(N(1,1)\)</span>. After collecting the sample, we would expect this distribution to become more precise, hence reduce the likelihood of making a wrong decision. The EVSI measures the expected improvement in net benefit from this sample.</p>
<p>Denote the study data as <span class="math inline">\(x_1,\ldots,x_n\)</span>, and suppose that they are distributed as <span class="math inline">\(x_i \sim N(p_1, \sigma)\)</span>. Hence the <em>mean</em> of the sample <span class="math inline">\(\bar{x} = \sum_{i=1^n} x_i\)</span> is a <em>summary statistic</em> containing the information provided by the data about <span class="math inline">\(p_1\)</span>.</p>
<p>Suppose for simplicity that the sampling variance <span class="math inline">\(\sigma\)</span> of the data is known to equal 1. The sample mean is then distributed as <span class="math inline">\(\bar{x} \sim N(p_1, \sigma / \sqrt{n})\)</span>.</p>
<p>To calculate the EVSI using this method, we generate a sample from the <em>predictive distribution</em> of this summary statistic under current information. This is achieved by generating a value of <span class="math inline">\(p_1\)</span> from its current <span class="math inline">\(N(1,1)\)</span> distribution, followed by a value of <span class="math inline">\(\bar{x}\)</span> from <span class="math inline">\(N(p_1, \sigma / \sqrt{n})\)</span>.</p>
<div id="function-to-generate-study-data" class="section level3">
<h3>Function to generate study data</h3>
<p>The function should generate a sample from the predictive distribution of the summary statistic, given a sample <code>inputs</code> from the current uncertainty distribution of the parameters.</p>
<p><code>inputs</code> has the same format as described above, a data frame with one row per sample and one column per parameter.</p>
<p>The function must return a data frame with one row per sample, and one column per parameter that is informed by the study data. Each data frame cell contains a summary statistic for that parameter from a simulated study.</p>
<p>The function <code>datagen_normal</code> below does this in a vectorised way for the example. Each row of the returned data frame is based on a different simulated <span class="math inline">\(p_1\)</span> taken from the first column of <code>inputs</code>, and contains a summary statistic <span class="math inline">\(\bar{x}\)</span> obtained from a dataset generated conditionally on that value of <span class="math inline">\(p_1\)</span>.</p>
<p>The sample size is included as an argument <code>n</code> to the data generation function. The names of the returned data-frame can be anything (<code>xbar</code> was used in this case to be descriptive).</p>
<p>The <code>evsi</code> function can then be used to compute the EVSI for a series of different sample sizes from this design. Note how the EVSI converges to the EVPPI as the sample size increases.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>datagen_normal <span class="ot">&lt;-</span> <span class="cf">function</span>(inputs, <span class="at">n=</span><span class="dv">100</span>, <span class="at">sigma=</span><span class="dv">1</span>){</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">data.frame</span>(<span class="at">xbar =</span> <span class="fu">rnorm</span>(<span class="at">n =</span> <span class="fu">nrow</span>(inputs),</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>                          <span class="at">mean =</span> inputs[,<span class="st">&quot;p1&quot;</span>],</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>                          <span class="at">sd =</span> sigma <span class="sc">/</span> <span class="fu">sqrt</span>(n)))</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="fu">evsi</span>(outputs_nb, inputs, <span class="at">datagen_fn =</span> datagen_normal, <span class="at">n=</span><span class="dv">10</span>)</span></code></pre></div>
<pre><code>## [1] 0.07184449</code></pre>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="fu">evsi</span>(outputs_nb, inputs, <span class="at">datagen_fn =</span> datagen_normal, <span class="at">n=</span><span class="dv">100</span>)</span></code></pre></div>
<pre><code>## [1] 0.08184203</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evsi</span>(outputs_nb, inputs, <span class="at">datagen_fn =</span> datagen_normal, <span class="at">n=</span><span class="dv">1000</span>)</span></code></pre></div>
<pre><code>## [1] 0.08177885</code></pre>
</div>
<div id="built-in-study-designs" class="section level3">
<h3>Built-in study designs</h3>
<p>The function <code>datagen_normal</code> is also included in the <code>voi</code> package as a built-in study design. To invoke the <code>evsi</code> function for a built-in study design, we have to supply the name of the design (in this case <code>&quot;normal_known&quot;</code>) and the name of the parameter or parameters (corresponding to a column of “inputs”) which is estimated by the study data. (Note that the results will vary every time the function is invoked due to Monte Carlo error)</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evsi</span>(outputs_nb, inputs, <span class="at">study =</span> <span class="st">&quot;normal_known&quot;</span>, <span class="at">n=</span><span class="dv">100</span>, <span class="at">pars =</span> <span class="st">&quot;p1&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 0.0809309</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evsi</span>(outputs_nb, inputs, <span class="at">study =</span> <span class="st">&quot;normal_known&quot;</span>, <span class="at">n=</span><span class="dv">1000</span>, <span class="at">pars =</span> <span class="st">&quot;p1&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 0.08226843</code></pre>
<p>Other built-in study designs include</p>
<p><code>&quot;binary&quot;</code>: A single sample of observations of a binary outcome. Requires one parameter to be specified in <code>pars</code>, that is, the probability of the outcome.</p>
<p><code>&quot;trial_binary&quot;</code>: A two-arm trial with a binary outcome. Requires two parameters to be specified in <code>pars</code>: the probability of the outcome in arm 1 and 2 respectively. The sample size is the same in each arm, specifed in the <code>n</code> argument to <code>evsi</code>, and the binomial outcomes are returned in the first and second column respectively.</p>
</div>
<div id="importance-sampling-method" class="section level3">
<h3>Importance sampling method</h3>
<p>An alternative method comes from <a href="https://doi.org/10.1177/0272989X15583495">Menzies</a> and is based on importance sampling. This can be invoked as <code>evsi(..., method=&quot;is&quot;)</code>.</p>
<p>As well as a data generation function in the above format, this also requires the user to supply a <em>likelihood function</em> for the study data.</p>
<p>This is illustrated here for the simple normal example. The likelihood function acts on one row of the data frame <span class="math inline">\(Y\)</span> which is produced by the data generation function, and returns a data frame with number of rows matching the rows of <code>inputs</code>. Each row of the returned data frame gives the sampling density for that row of <span class="math inline">\(Y\)</span> given the corresponding parameter values in <code>inputs</code>. The corresponding EVSI calculation then involves building a large matrix of likelihoods for combinations of simulated datasets and simulated parameters.</p>
<p>Any user-supplied likelihood function should consistently define the same model for the data as the data generation function (the package does not check this!), and any names of parameters and outputs should match the names defined in <code>inputs</code> and the data generation function.</p>
<p>This method is typically slower than the default nonparametric regression method, so it may be worth setting <code>nsim</code> to a value lower than the number of samples in <code>inputs</code>. Below <code>nsim=1000</code> is used so that only 1000 samples are used, instead of the full 10000 samples contained in <code>inputs</code>.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>likelihood_normal <span class="ot">&lt;-</span> <span class="cf">function</span>(Y, inputs, <span class="at">n=</span><span class="dv">100</span>, <span class="at">sig=</span><span class="dv">1</span>){</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> inputs[,<span class="st">&quot;p1&quot;</span>]</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">dnorm</span>(Y[,<span class="st">&quot;xbar&quot;</span>], mu, sig<span class="sc">/</span><span class="fu">sqrt</span>(n))</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="fu">evsi</span>(outputs_nb, inputs, <span class="at">datagen_fn =</span> datagen_normal, <span class="at">likelihood =</span> likelihood_normal, </span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>     <span class="at">n=</span><span class="dv">100</span>, <span class="at">pars =</span> <span class="st">&quot;p1&quot;</span>, <span class="at">method=</span><span class="st">&quot;is&quot;</span>, <span class="at">nsim=</span><span class="dv">1000</span>)</span></code></pre></div>
<pre><code>## [1] 0.08917379</code></pre>
<p>Again, this study model is available as a built-in study design, so instead of writing a user-defined likelihood and data generation function, <code>evsi</code> can also be invoked with <code>study=&quot;normal_known&quot;, method=&quot;is&quot;</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">evsi</span>(outputs_nb, inputs, <span class="at">study =</span> <span class="st">&quot;normal_known&quot;</span>, <span class="at">n=</span><span class="dv">100</span>, <span class="at">pars =</span> <span class="st">&quot;p1&quot;</span>, <span class="at">method=</span><span class="st">&quot;is&quot;</span>, <span class="at">nsim=</span><span class="dv">1000</span>)</span></code></pre></div>
<pre><code>## [1] 0.08603906</code></pre>
</div>
<div id="further-work" class="section level3">
<h3>Further work</h3>
<p>Other EVSI calculation methods (including <a href="https://doi.org/10.1177/0272989X19837983">Heath et al</a>) are planned to be implemented.</p>
<p>As the book is developed, any useful features required will be added to the package.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
